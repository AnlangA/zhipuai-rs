//! chat model data structure
use serde::{Deserialize, Deserializer, Serialize};
use std::any::{Any, TypeId};
use std::collections::HashMap;
use std::fmt;

/// The context of the current conversation
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Message {
    /// Current conversation role, default is 'assistant' (model)
    role: String,
    /// Current conversation content. It is null when a function is hit, otherwise, it returns the model reasoning result.
    #[serde(skip_serializing_if = "Option::is_none")]
    content: Option<Context>,
    #[serde(skip_serializing_if = "Option::is_none")]
    /// Function names and parameters generated by the model to be called.
    tool_calls: Option<Vec<ToolCall>>,
}

impl fmt::Display for Message {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "\nRole: {}\n", self.role)?;
        match &self.content {
            Some(content) => {
                write!(f, "Content: {}", content)?;
            }
            None => {
                write!(f, "Role: {}\nTool Calls:", self.role)?;
                match &self.tool_calls {
                    Some(calls) => {
                        // 如果存在，则打印每个 ToolCall
                        for tool_call in calls {
                            write!(f, "\n  {}", tool_call)?;
                        }
                    }
                    None => {
                        write!(f, " None")?;
                    }
                }
            }
        }
        Ok(())
    }
}

#[allow(dead_code)]
impl Message {
    pub fn new(role: &str, content: Option<Context>, tool_calls: Option<Vec<ToolCall>>) -> Self {
        Self {
            role: role.to_string(),
            content,
            tool_calls,
        }
    }
    /// Get the content of the current conversation
    pub fn simple_context(&self) -> Option<(&str, &str)> {
        match &self.content {
            Some(Context::SimpleContexts(content)) => Some((&self.role,content)),
            _ => None,
        }
    }
}

/// making generate Messages esay
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Messages{
    pub messages: Vec<Message>,
}

impl Messages {
    /// Create a new Messages with an empty list of messages
    pub fn new() -> Self {
        Self { messages: vec![] }
    }
    /// 
    pub fn add_message(mut self, message: Message) ->Self {
        self.messages.push(message);
        self
    }
}

/// The context of the current conversation
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum Context {
    SimpleContexts(String),
    RichContents(Vec<RichContent>),
}

impl Context {
    pub fn new_simple_contexts(content: &str) -> Self {
        Context::SimpleContexts(content.to_string())
    }
    pub fn new_rich_contexts(content: RichContent) -> Self {
        Context::RichContents(vec![content])
    }
    pub fn add_rich_content(mut self, content: RichContent) -> Self {
        match &mut self {
            Context::SimpleContexts(_) => Context::RichContents(vec![content]),
            Context::RichContents(contents) => {
                contents.push(content);
                self
            }
        }
    }
}

impl fmt::Display for Context {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Context::SimpleContexts(content) => write!(f, "{}", content),
            Context::RichContents(contents) => {
                for content in contents {
                    write!(f, "{}", content)?;
                }
                Ok(())
            }
        }
    }
}

/// The content of the current conversation when use glm-4v to explain the content in pictures and videos.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct RichContent {
    #[serde(rename = "type")]
    item_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    video_url: Option<VideoUrl>,
    #[serde(skip_serializing_if = "Option::is_none")]
    image_url: Option<ImageUrl>,
    #[serde(skip_serializing_if = "Option::is_none")]
    text: Option<String>,
}

/// video url when use RichContent
#[derive(Serialize, Deserialize, Debug, Clone)]
struct VideoUrl {
    url: String,
}

/// image url when use RichContent
#[derive(Serialize, Deserialize, Debug, Clone)]
struct ImageUrl {
    url: String,
}

impl RichContent {
    pub fn new_image_url(url: &str) -> Self {
        Self {
            item_type: "image_url".to_string(),
            video_url: None,
            image_url: Some(ImageUrl {
                url: url.to_string(),
            }),
            text: None,
        }
    }
    pub fn new_video_url(url: &str) -> Self {
        Self {
            item_type: "video_url".to_string(),
            video_url: Some(VideoUrl {
                url: url.to_string(),
            }),
            image_url: None,
            text: None,
        }
    }
    pub fn new_text(text: &str) -> Self {
        Self {
            item_type: "text".to_string(),
            video_url: None,
            image_url: None,
            text: Some(text.to_string()),
        }
    }
}

impl fmt::Display for RichContent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "RichContent: {:?}", self)
    }
}

/// The tools of chat model
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Tool {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    tool_type: Option<ToolType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    web_search: Option<WebSearch>,
    #[serde(skip_serializing_if = "Option::is_none")]
    function: Option<Function>,
    #[serde(skip_serializing_if = "Option::is_none")]
    retrieval: Option<Retrieval>,
}

impl Tool {
    pub fn new() -> Self {
        Self {
            tool_type: None,
            web_search: None,
            function: None,
            retrieval: None,
        }
    }
    /// use `seb_search` tool
    pub fn web_search(mut self, web_search: WebSearch) -> Self {
        self.check_type(&web_search);
        self.web_search = Some(web_search);
        self
    }
    /// use `function` tool
    pub fn function(mut self, function: Function) -> Self {
        self.check_type(&function);
        self.function = Some(function);
        self
    }
    /// use `retrieval` tool
    pub fn retrieval(mut self, retrieval: Retrieval) -> Self {
        self.check_type(&retrieval);
        self.retrieval = Some(retrieval);
        self
    }
    /// check tool type and modify `type` of tool
    fn check_type<T: Any>(&mut self, _value: &T) {
        let type_id = TypeId::of::<T>();
        if type_id == TypeId::of::<WebSearch>() {
            self.tool_type = Some(ToolType::web_search);
        } else if type_id == TypeId::of::<Function>() {
            self.tool_type = Some(ToolType::function)
        } else if type_id == TypeId::of::<Retrieval>() {
            self.tool_type = Some(ToolType::retrieval)
        }
    }
}

/// tools type
#[derive(Serialize, Deserialize, Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum ToolType {
    function,
    retrieval,
    web_search,
}

/// Tool response
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ToolCall {
    #[serde(rename = "type")]
    call_type: String,
    function: FunctionRespon,
    id: String,
    index: u32,
}
impl fmt::Display for ToolCall {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ToolCall ID: {}\nIndex: {}\nType: {}\n{}",
            self.id, self.index, self.call_type, self.function
        )
    }
}
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct FunctionRespon {
    name: String,
    #[serde(deserialize_with = "deserialize_arguments")]
    arguments: HashMap<String, String>, // 直接使用 HashMap 来解析 arguments 字段
}
impl fmt::Display for FunctionRespon {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Function Name: {}\nArguments:", self.name)?;
        for (key, value) in &self.arguments {
            write!(f, "\n  {}: {}", key, value)?;
        }

        Ok(())
    }
}
fn deserialize_arguments<'de, D>(deserializer: D) -> Result<HashMap<String, String>, D::Error>
where
    D: Deserializer<'de>,
{
    let s: String = Deserialize::deserialize(deserializer)?;
    let map: HashMap<String, String> =
        serde_json::from_str(&s).map_err(serde::de::Error::custom)?;
    Ok(map)
}

/// function call data object
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Function {
    /// The name of the function
    name: String,
    /// The description of the function
    description: String,
    /// The list of arguments for the function call generated by the model, in JSON format.
    /// Note that the model may generate invalid JSON or fictional parameters not present in your function specification.
    /// Please validate these parameters in your code before calling the function.
    parameters: Parameters,
}
impl Function {
    pub fn new(name: &str, description: &str, parameters: Parameters) -> Self {
        Self {
            name: name.to_string(),
            description: description.to_string(),
            parameters: parameters,
        }
    }
}

/// function call parameters object
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Parameters {
    #[serde(rename = "type")]
    param_type: String,
    properties: HashMap<String, Property>,
    required: Vec<String>,
}

impl Parameters {
    pub fn new(properties: HashMap<String, Property>) -> Self {
        let required = properties.keys().map(|k| k.to_string()).collect();
        Self {
            param_type: "object".to_string(),
            properties: properties,
            required: required,
        }
    }
}

/// function call children object
#[derive(Serialize, Deserialize, PartialEq, Eq, Debug, Clone)]
pub struct Property {
    #[serde(rename = "type")]
    prop_type: String,
    description: String,
}
impl Property {
    pub fn new(prop_type: &str, description: &str) -> Property {
        Property {
            prop_type: prop_type.to_string(),
            description: description.to_string(),
        }
    }
}

/// `retrieval` tool object
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Retrieval {
    knowledge_id: String,
    prompt_template: Option<String>,
}
impl Retrieval {
    pub fn new(knowledge_id: &str, prompt_template: Option<String>) -> Self {
        Self {
            knowledge_id: knowledge_id.to_string(),
            prompt_template,
        }
    }
}

/// `code` tool object
/// `web_search` tool configuration
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct WebSearch {
    /// Whether to enable web search
    enable: bool,
    /// The search query, what key worlds you want to search
    search_query: Option<String>,
    /// Whether to return the all search information
    search_result: Option<bool>,
    /// make the search display by configuration
    search_prompt: Option<String>,
}
impl WebSearch {
    pub fn new() -> Self {
        Self {
            enable: true,
            search_query: None,
            search_result: None,
            search_prompt: None,
        }
    }
    /// configure the key words of search result
    pub fn search_query(mut self, search_query: &str) -> Self {
        self.search_query = Some(search_query.to_string());
        self
    }
    /// configure whether to return the all search information
    pub fn search_result(mut self, search_result: bool) -> Self {
        self.search_result = Some(search_result);
        self
    }
    /// configure the search prompt。when `search_prompt` is `Some`，`search_result` will be `Some(true)`
    pub fn search_prompt(mut self, search_prompt: &str) -> Self {
        self.search_result = Some(true);
        self.search_prompt = Some(search_prompt.to_string());
        self
    }
}

/// response message object
#[derive(Debug, Serialize, Deserialize)]
pub struct Choice {
    /// The reason of the generation stop
    finish_reason: String,
    /// The index of the generated message
    index: u32,
    /// The response messages of the model
    message: Message,
}

impl Choice {
    pub fn message(&self) -> &Message {
        &self.message
    }
}

/// tokens usage object
#[derive(Debug, Serialize, Deserialize)]
pub struct Usage {
    /// Number of tokens input by the user
    prompt_tokens: u32,
    /// Number of tokens output by the model
    completion_tokens: u32,
    /// Total number of tokens
    total_tokens: u32,
}

/// web search response object
#[derive(Debug, Serialize, Deserialize)]
pub struct WebSearchResponse {
    content: Option<String>,
    icon: Option<String>,
    link: Option<String>,
    media: Option<String>,
    refer: Option<String>,
    title: Option<String>,
}
#[allow(dead_code)]
impl WebSearchResponse {
    fn get_content(&self) -> Option<&String> {
        self.content.as_ref()
    }
    fn get_icon(&self) -> Option<&String> {
        self.icon.as_ref()
    }
    fn get_link(&self) -> Option<&String> {
        self.link.as_ref()
    }
    fn get_media(&self) -> Option<&String> {
        self.media.as_ref()
    }
    fn get_refer(&self) -> Option<&String> {
        self.refer.as_ref()
    }
    fn get_title(&self) -> Option<&String> {
        self.title.as_ref()
    }
}
impl fmt::Display for WebSearchResponse {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "content: {},\n icon: {},\n link: {},\n media: {},\n refer: {},\n title: {}",
            self.get_content()
                .get_or_insert(&"content is null".to_string()),
            self.get_icon().get_or_insert(&"icon is null".to_string()),
            self.get_link().get_or_insert(&"link is null".to_string()),
            self.get_media().get_or_insert(&"media is null".to_string()),
            self.get_refer().get_or_insert(&"refer is null".to_string()),
            self.get_title().get_or_insert(&"title is null".to_string())
        )
    }
}

/// when use codegeex, it will be used
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Extra {
    #[serde(skip_serializing_if = "Option::is_none")]
    target: Option<Target>,
    #[serde(skip_serializing_if = "Option::is_none")]
    contexts: Option<Vec<CodeContext>>,
}

impl Extra {
    pub fn new(target: Target) -> Self {
        Self {
            target: Some(target),
            contexts: None,
        }
    }
    pub fn add_context(mut self, context: CodeContext) -> Self {
        if let Some(mut contexts) = self.contexts {
            contexts.push(context);
            self.contexts = Some(contexts);
        } else {
            self.contexts = Some(vec![context]);
        }
        self
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Target {
    // file path
    #[serde(skip_serializing_if = "Option::is_none")]
    path: Option<String>,
    // code prefix
    #[serde(skip_serializing_if = "Option::is_none")]
    code_prefix: Option<String>,
    // code suffix
    #[serde(skip_serializing_if = "Option::is_none")]
    code_suffix: Option<String>,
}

impl Target {
    pub fn new(
        path: Option<String>,
        code_prefix: Option<String>,
        code_suffix: Option<String>,
    ) -> Self {
        Self {
            path,
            code_prefix,
            code_suffix,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct CodeContext {
    // file path
    #[serde(skip_serializing_if = "Option::is_none")]
    path: Option<String>,
    // code
    #[serde(skip_serializing_if = "Option::is_none")]
    code: Option<String>,
}

impl CodeContext {
    pub fn new(path: Option<String>, code: Option<String>) -> Self {
        Self { path, code }
    }
}
