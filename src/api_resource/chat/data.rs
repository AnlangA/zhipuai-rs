//! chat model data structure
use serde::{Deserialize, Deserializer, Serialize};
use std::{
    any::{Any, TypeId},
    collections::HashMap,
    fmt,
};

/// The context of the current conversation
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Message {
    /// Current conversation role, default is 'assistant' (model)
    role: String,
    /// Current conversation content. It is null when a function is hit, otherwise, it returns the model reasoning result.
    #[serde(skip_serializing_if = "Option::is_none")]
    content: Option<Context>,
    /// Content of the thought chain
    #[serde(skip_serializing_if = "Option::is_none")]
    reasoning_content: Option<String>,
    /// Function names and parameters generated by the model to be called.
    #[serde(skip_serializing_if = "Option::is_none")]
    tool_calls: Option<Vec<ToolCall>>,
}

impl fmt::Display for Message {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "\nRole: {}\n", self.role)?;
        match &self.content {
            Some(content) => {
                write!(f, "Content: {}", content)?;
            }
            None => {
                write!(f, "Role: {}\nTool Calls:", self.role)?;
                match &self.tool_calls {
                    Some(calls) => {
                        for tool_call in calls {
                            write!(f, "\n  {}", tool_call)?;
                        }
                    }
                    None => {
                        write!(f, " None")?;
                    }
                }
            }
        }
        Ok(())
    }
}

#[allow(dead_code)]
impl Message {
    pub fn new(role: &str, content: Option<Context>, tool_calls: Option<Vec<ToolCall>>) -> Self {
        Self {
            role: role.to_string(),
            content,
            reasoning_content: None,
            tool_calls,
        }
    }
    /// Get the content of the current conversation
    pub fn simple_context(&self) -> Option<(&str, &str)> {
        match &self.content {
            Some(Context::SimpleContexts(content)) => Some((&self.role, content)),
            _ => None,
        }
    }
}

/// making generate Messages essay
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Messages {
    pub messages: Vec<Message>,
}

impl Messages {
    /// Create a new Messages with an empty list of messages
    pub fn new() -> Self {
        Self { messages: vec![] }
    }
    /// add a message to the list of messages
    pub fn add_message(mut self, message: Message) -> Self {
        self.messages.push(message);
        self
    }
    /// Get the content of the current conversation
    pub fn to_string(&self) -> String {
        self.messages
            .iter()
            .map(|msg| msg.to_string())
            .collect::<Vec<String>>()
            .join("\n")
    }
    /// Clear messages
    pub fn clear(&mut self) {
        self.messages.clear();
    }
}

/// The context of the current conversation
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum Context {
    SimpleContexts(String),
    RichContents(Vec<RichContent>),
}

impl Context {
    pub fn simple_context(content: &str) -> Self {
        Context::SimpleContexts(content.to_string())
    }

    pub fn rich_contexts(content: RichContent) -> Self {
        Context::RichContents(vec![content])
    }

    pub fn rich_content(mut self, content: RichContent) -> Self {
        match &mut self {
            Context::SimpleContexts(_) => Context::RichContents(vec![content]),
            Context::RichContents(contents) => {
                contents.push(content);
                self
            }
        }
    }
}

impl fmt::Display for Context {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Context::SimpleContexts(content) => write!(f, "{}", content),
            Context::RichContents(contents) => {
                for content in contents {
                    write!(f, "{}", content)?;
                }
                Ok(())
            }
        }
    }
}

/// The content of the current conversation when use glm-4v to explain the content in pictures and videos.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct RichContent {
    #[serde(rename = "type")]
    item_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    text: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    video_url: Option<VideoUrl>,
    #[serde(skip_serializing_if = "Option::is_none")]
    image_url: Option<ImageUrl>,
    #[serde(skip_serializing_if = "Option::is_none")]
    input_audio: Option<Audio>,
}

/// video url when use RichContent
#[derive(Serialize, Deserialize, Debug, Clone)]
struct VideoUrl {
    url: String,
}

/// image url when use RichContent
#[derive(Serialize, Deserialize, Debug, Clone)]
struct ImageUrl {
    url: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Audio {
    data: String,
    format: String,
}

impl RichContent {
    // 创建一个包含图片URL的RichContent实例
    pub fn image_url(url: &str) -> Self {
        Self {
            item_type: "image_url".to_string(),
            video_url: None,
            image_url: Some(ImageUrl {
                url: url.to_string(),
            }),
            input_audio: None,
            text: None,
        }
    }

    // 创建一个包含视频URL的RichContent实例
    pub fn video_url(url: &str) -> Self {
        Self {
            item_type: "video_url".to_string(),
            video_url: Some(VideoUrl {
                url: url.to_string(),
            }),
            image_url: None,
            input_audio: None,
            text: None,
        }
    }

    // 创建一个包含文本的RichContent实例
    pub fn text(text: &str) -> Self {
        Self {
            item_type: "text".to_string(),
            video_url: None,
            image_url: None,
            input_audio: None,
            text: Some(text.to_string()),
        }
    }

    pub fn audio(data: &str) -> Self {
        Self {
            item_type: "input_audio".to_string(),
            video_url: None,
            image_url: None,
            input_audio: Some(Audio {
                data: data.to_string(),
                format: "awv".to_string(),
            }),
            text: None,
        }
    }
}

impl fmt::Display for RichContent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "RichContent: {:?}", self)
    }
}

/// The tools of chat model
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Tool {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    tool_type: Option<ToolType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    web_search: Option<WebSearch>,
    #[serde(skip_serializing_if = "Option::is_none")]
    function: Option<Function>,
    #[serde(skip_serializing_if = "Option::is_none")]
    retrieval: Option<Retrieval>,
    #[serde(skip_serializing_if = "Option::is_none")]
    code_interpreter: Option<CodeInterPerter>,
    #[serde(skip_serializing_if = "Option::is_none")]
    drawing_tool: Option<DrawingTool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    web_browser: Option<WebBrowser>,
}

impl Tool {
    pub fn new() -> Self {
        Self {
            tool_type: None,
            web_search: None,
            function: None,
            retrieval: None,
            code_interpreter: None,
            drawing_tool: None,
            web_browser: None,
        }
    }
    /// use `seb_search` tool
    pub fn web_search(mut self, web_search: WebSearch) -> Self {
        self.check_type(&web_search);
        self.web_search = Some(web_search);
        self
    }
    /// use `function` tool
    ///
    pub fn function(mut self, function: Function) -> Self {
        self.check_type(&function);
        self.function = Some(function);
        self
    }

    /// use `retrieval` tool
    pub fn retrieval(mut self, retrieval: Retrieval) -> Self {
        self.check_type(&retrieval);
        self.retrieval = Some(retrieval);
        self
    }

    /// use `code_interpreter` tool
    pub fn code_interpreter(mut self, code_interpreter: CodeInterPerter) -> Self {
        self.check_type(&code_interpreter);
        self.code_interpreter = Some(code_interpreter);
        self
    }

    /// use `drawing_tool` tool
    pub fn drawing_tool(mut self, drawing_tool: DrawingTool) -> Self {
        self.check_type(&drawing_tool);
        self.drawing_tool = None;
        self
    }

    /// use `web_browser` tool
    pub fn web_browser(mut self, web_browser: WebBrowser) -> Self {
        self.check_type(&web_browser);
        self.web_browser = Some(web_browser);
        self
    }

    /// check tool type and modify `type` of tool
    fn check_type<T: Any>(&mut self, _value: &T) {
        let type_id = TypeId::of::<T>();
        if type_id == TypeId::of::<WebSearch>() {
            self.tool_type = Some(ToolType::web_search);
        } else if type_id == TypeId::of::<Function>() {
            self.tool_type = Some(ToolType::function)
        } else if type_id == TypeId::of::<Retrieval>() {
            self.tool_type = Some(ToolType::retrieval)
        } else if type_id == TypeId::of::<CodeInterPerter>() {
            self.tool_type = Some(ToolType::code_interpreter)
        } else if type_id == TypeId::of::<DrawingTool>() {
            self.tool_type = Some(ToolType::drawing_tool)
        } else if type_id == TypeId::of::<WebBrowser>() {
            self.tool_type = Some(ToolType::web_browser)
        }
    }
}

/// tools type
#[derive(Serialize, Deserialize, Debug, Clone)]
#[allow(non_camel_case_types)]
pub enum ToolType {
    function,
    retrieval,
    web_search,
    code_interpreter,
    drawing_tool,
    web_browser,
}

/// Tool response
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ToolCall {
    id: Option<String>,
    #[serde(rename = "type")]
    call_type: Option<String>,
    function: Option<FunctionRespond>,
    drawing_tool: Option<DrawingToolRespond>,
    index: Option<u32>,
}

impl fmt::Display for ToolCall {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut output = String::new();

        if let Some(id) = &self.id {
            output.push_str(&format!("ToolCall ID: {}\n", id));
        }
        if let Some(index) = &self.index {
            output.push_str(&format!("Index: {}\n", index));
        }
        if let Some(call_type) = &self.call_type {
            output.push_str(&format!("Type: {}\n", call_type));
        }
        if let Some(function) = &self.function {
            output.push_str(&format!("Function: {}\n", function));
        }
        if let Some(drawing_tool) = &self.drawing_tool {
            output.push_str(&format!("Drawing Tool: {}\n", drawing_tool));
        }
        // Write the final output string to the formatter
        write!(f, "{}", output)
    }
}
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct FunctionRespond {
    name: String,
    #[serde(deserialize_with = "deserialize_arguments")]
    arguments: HashMap<String, String>, // 直接使用 HashMap 来解析 arguments 字段
}
impl fmt::Display for FunctionRespond {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Function Name: {}\nArguments:", self.name)?;
        for (key, value) in &self.arguments {
            write!(f, "\n  {}: {}", key, value)?;
        }

        Ok(())
    }
}
fn deserialize_arguments<'de, D>(deserializer: D) -> Result<HashMap<String, String>, D::Error>
where
    D: Deserializer<'de>,
{
    let s: String = Deserialize::deserialize(deserializer)?;
    let map: HashMap<String, String> =
        serde_json::from_str(&s).map_err(serde::de::Error::custom)?;
    Ok(map)
}

/// function call data object
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Function {
    r#type: String,
    /// The name of the function
    name: String,
    /// The description of the function
    description: String,
    /// The list of arguments for the function call generated by the model, in JSON format.
    /// Note that the model may generate invalid JSON or fictional parameters not present in your function specification.
    /// Please validate these parameters in your code before calling the function.
    parameters: Parameters,
}

impl Function {
    pub fn new(name: &str, description: &str, parameters: Parameters) -> Self {
        Self {
            r#type: "function".to_string(),
            name: name.to_string(),
            description: description.to_string(),
            parameters,
        }
    }
}

/// function call parameters object
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Parameters {
    #[serde(rename = "type")]
    param_type: String,
    properties: HashMap<String, Property>,
    required: Option<Vec<String>>,
}

impl Parameters {
    pub fn new(properties: HashMap<String, Property>) -> Self {
        let required = properties.keys().map(|k| k.to_string()).collect();
        Self {
            param_type: "object".to_string(),
            properties,
            required: Some(required),
        }
    }
}

/// function call children object
#[derive(Serialize, Deserialize, PartialEq, Eq, Debug, Clone)]
pub struct Property {
    #[serde(rename = "type")]
    prop_type: String,
    description: String,
}

impl Property {
    pub fn new(prop_type: &str, description: &str) -> Property {
        Property {
            prop_type: prop_type.to_string(),
            description: description.to_string(),
        }
    }
}

/// `retrieval` tool object
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Retrieval {
    knowledge_id: String,
    prompt_template: Option<String>,
}

impl Retrieval {
    pub fn new(knowledge_id: &str, prompt_template: Option<String>) -> Self {
        Self {
            knowledge_id: knowledge_id.to_string(),
            prompt_template,
        }
    }
}

/// `code` tool object
/// `web_search` tool configuration
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct WebSearch {
    /// Whether to enable web search
    enable: bool,
    /// The search query, what key worlds you want to search
    search_query: Option<String>,
    /// Whether to return the all search information
    search_result: Option<bool>,
    /// make the search display by configuration
    search_prompt: Option<String>,
}

impl WebSearch {
    pub fn new() -> Self {
        Self {
            enable: true,
            search_query: None,
            search_result: None,
            search_prompt: None,
        }
    }
    /// configure the keywords of search result
    pub fn search_query(mut self, search_query: &str) -> Self {
        self.search_query = Some(search_query.to_string());
        self
    }
    /// configure whether to return the all search information
    pub fn search_result(mut self, search_result: bool) -> Self {
        self.search_result = Some(search_result);
        self
    }
    /// configure the search prompt。when `search_prompt` is `Some`，`search_result` will be `Some(true)`
    pub fn search_prompt(mut self, search_prompt: &str) -> Self {
        self.search_result = Some(true);
        self.search_prompt = Some(search_prompt.to_string());
        self
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct CodeInterPerter {
    /// Whether to enable code sandbox. if enabled, the server will execute the code in a sandbox environment
    sandbox: SandBox,
    #[serde(skip_serializing_if = "Option::is_none")]
    file_ids: Option<Vec<String>>,
}

impl Default for CodeInterPerter {
    fn default() -> Self {
        Self {
            sandbox: SandBox::Auto,
            file_ids: Some(Vec::new()),
        }
    }
}

impl CodeInterPerter {
    pub fn new() -> Self {
        Self {
            sandbox: SandBox::Auto,
            file_ids: Some(Vec::new()),
        }
    }
    pub fn sandbox(mut self, sandbox: SandBox) -> Self {
        self.sandbox = sandbox;
        self
    }
    pub fn file_ids(mut self, file_ids: String) -> Self {
        self.file_ids.as_mut().unwrap().push(file_ids);
        self
    }
}

/// Specify the code sandbox environment. auto by default, which means automatically calling the sandbox environment
/// to execute code. After setting `sandbox = none `, the sandbox environment is not enabled.
/// After the code is generated, the returned status is ` status = requires_action `,
/// requiring the user to submit the code execution result.
#[derive(Debug, Serialize, Deserialize, Clone, Copy)]
pub enum SandBox {
    #[serde(rename = "auto")]
    Auto,
    #[serde(rename = "none")]
    None,
}

/// drawing tool. You only need to upload type; this doesn't need to be uploaded.
#[derive(Debug, Serialize, Deserialize, Clone, Copy)]
pub struct DrawingTool;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DrawingToolRespond {
    input: Option<String>,
    outputs: Option<Vec<Output>>,
}

impl fmt::Display for DrawingToolRespond {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut tool_data = String::new();
        if let Some(data) = &self.input {
            tool_data = format!("input: {}", data);
        }
        if let Some(outputs) = &self.outputs {
            let image_urls: Vec<String> =
                outputs.iter().map(|output| output.image.clone()).collect();
            tool_data = format!("outputs: {:?}", image_urls);
        }
        write!(f, "{}", tool_data)
    }
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Output {
    image: String,
}

/// drawing tool. You only need to upload type; this doesn't need to be uploaded.
/// By default, `browser` = auto automatically browses the web pages for the links in the search results and the entered URLs.
/// If only the summary information of the search is needed, and the browsing tool is not used, it can be disabled by setting `browser`` = none.
#[derive(Debug, Serialize, Deserialize, Clone, Copy)]
pub struct WebBrowser {
    browser: Browser,
}

impl Default for WebBrowser {
    fn default() -> Self {
        Self {
            browser: Browser::Auto,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, Copy)]
enum Browser {
    #[serde(rename = "auto")]
    Auto,
    #[serde(rename = "none")]
    None,
}

/// response message object
#[derive(Debug, Serialize, Deserialize)]
pub struct Choice {
    /// The reason of the generation stop
    finish_reason: String,
    /// The index of the generated message
    index: u32,
    /// The response messages of the model
    message: Message,
}

impl Choice {
    pub fn message(&self) -> &Message {
        &self.message
    }
}

/// tokens usage object
#[derive(Debug, Serialize, Deserialize)]
pub struct Usage {
    /// Number of tokens input by the user
    prompt_tokens: u32,
    /// Number of tokens output by the model
    completion_tokens: u32,
    /// Total number of tokens
    total_tokens: u32,
}

/// web search response object
#[derive(Debug, Serialize, Deserialize)]
pub struct WebSearchResponse {
    content: Option<String>,
    icon: Option<String>,
    link: Option<String>,
    media: Option<String>,
    refer: Option<String>,
    title: Option<String>,
}
#[allow(dead_code)]
impl WebSearchResponse {
    fn get_content(&self) -> Option<&String> {
        self.content.as_ref()
    }
    fn get_icon(&self) -> Option<&String> {
        self.icon.as_ref()
    }
    fn get_link(&self) -> Option<&String> {
        self.link.as_ref()
    }
    fn get_media(&self) -> Option<&String> {
        self.media.as_ref()
    }
    fn get_refer(&self) -> Option<&String> {
        self.refer.as_ref()
    }
    fn get_title(&self) -> Option<&String> {
        self.title.as_ref()
    }
}

impl fmt::Display for WebSearchResponse {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "content: {},\n icon: {},\n link: {},\n media: {},\n refer: {},\n title: {}",
            self.get_content()
                .get_or_insert(&"content is null".to_string()),
            self.get_icon().get_or_insert(&"icon is null".to_string()),
            self.get_link().get_or_insert(&"link is null".to_string()),
            self.get_media().get_or_insert(&"media is null".to_string()),
            self.get_refer().get_or_insert(&"refer is null".to_string()),
            self.get_title().get_or_insert(&"title is null".to_string())
        )
    }
}

/// when use codegeex, it will be used
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Extra {
    #[serde(skip_serializing_if = "Option::is_none")]
    target: Option<Target>,
    #[serde(skip_serializing_if = "Option::is_none")]
    contexts: Option<Vec<CodeContext>>,
}

impl Extra {
    pub fn new(target: Target) -> Self {
        Self {
            target: Some(target),
            contexts: None,
        }
    }
    pub fn add_context(mut self, context: CodeContext) -> Self {
        if let Some(mut contexts) = self.contexts {
            contexts.push(context);
            self.contexts = Some(contexts);
        } else {
            self.contexts = Some(vec![context]);
        }
        self
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Target {
    // file path
    #[serde(skip_serializing_if = "Option::is_none")]
    path: Option<String>,
    // language
    #[serde(skip_serializing_if = "Option::is_none")]
    language: Option<String>,
    // code prefix
    #[serde(skip_serializing_if = "Option::is_none")]
    code_prefix: Option<String>,
    // code suffix
    #[serde(skip_serializing_if = "Option::is_none")]
    code_suffix: Option<String>,
}

impl Target {
    pub fn new(
        path: Option<String>,
        language: Option<String>,
        code_prefix: Option<String>,
        code_suffix: Option<String>,
    ) -> Self {
        Self {
            path,
            language,
            code_prefix,
            code_suffix,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct CodeContext {
    // file path
    #[serde(skip_serializing_if = "Option::is_none")]
    path: Option<String>,
    // code
    #[serde(skip_serializing_if = "Option::is_none")]
    code: Option<String>,
}

impl CodeContext {
    pub fn new(path: Option<String>, code: Option<String>) -> Self {
        Self { path, code }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Thinking {
    #[serde(rename = "type")]
    thinking: String,
}

impl Default for Thinking {
    fn default() -> Self {
        Self {
            thinking: "enabled".to_string(),
        }
    }
}

impl Thinking {
    pub fn enabled() -> Self {
        Self {
            thinking: "enabled".to_string(),
        }
    }

    pub fn disabled() -> Self {
        Self {
            thinking: "disabled".to_string(),
        }
    }
}
